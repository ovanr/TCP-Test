{-
TorXakis - Model Based Testing
Copyright (c) 2015-2021 ESI (TNO) and Radboud University
See LICENSE at root directory of this repository.
-}


TYPEDEF TCPFlag ::= SYN | ACK | FIN | RST ENDDEF
TYPEDEF SEQ ::= SEQ_VALID | SEQ_INVALID ENDDEF
TYPEDEF ACK ::= ACK_VALID | ACK_INVALID ENDDEF

-- order is implied
TYPEDEF TCPFlagList ::=   
    NIL
    | CONS  { hd :: TCPFlag ; tl :: TCPFlagList }
ENDDEF

TYPEDEF TCPUserCallInput ::= 
    LISTEN { lport :: Int }
    | CONNECT { cport :: Int }
    | SEND { spayload :: String }
    | RECEIVE 
    | CLOSE
ENDDEF
TYPEDEF TCPUserCallOutput ::= 
    SUCCESS
    | FAILURE
    | RECEIVE { rpayload :: String }
ENDDEF

TYPEDEF TCPPacket ::= TCPPacket { 
        sport :: Int;
        dport :: Int;
        seq :: SEQ;
        ack :: ACK;
        flags :: TCPFlagList;
        payload :: String
    } 
ENDDEF

-- ----------------------------------------------------------------------------------------- --
-- channel definitions
--   In  :  channel with messages of type QueueOp
--   Out :  channel with messages of type Int

CHANDEF  Channels  ::=    InSutNet   :: TCPPacket; 
                          OutSutNet   :: TCPPacket; 
                          InSutUser   :: TCPUserCallInput; 
                          OutSutUser   :: TCPUserCallOutput
ENDDEF

FUNCDEF isListenUserCall ( c :: TCPUserCallInput ) :: Bool ::=
    IF isLISTEN(c) THEN
        (lport(c) > 4000) /\ (lport(c) < 5000)
    ELSE
        False
    FI
ENDDEF

FUNCDEF isConnectUserCall ( c :: TCPUserCallInput ) :: Bool ::=
    IF isCONNECT(c) THEN
        (cport(c) > 4000) /\ (cport(c) < 5000)
    ELSE
        False
    FI
ENDDEF

FUNCDEF isSyn ( t :: TCPPacket ) :: Bool ::=
    (flags(t) == CONS(SYN, NIL)) /\
    (payload(t) == "") /\
    (seq(t) == SEQ_VALID) /\
    (ack(t) == ACK_VALID) /\
    (sport(t) > 4000) /\ 
    (sport(t) < 5000)
ENDDEF

FUNCDEF isSynAck ( t :: TCPPacket ) :: Bool ::=
    (flags(t) == CONS(ACK, CONS(SYN, NIL))) /\
    (payload(t) == "") /\
    (seq(t) == SEQ_VALID) /\
    (ack(t) == ACK_VALID)
ENDDEF

FUNCDEF isAck ( t :: TCPPacket ) :: Bool ::=
    (flags(t) == CONS(ACK, NIL)) /\
    (seq(t) == SEQ_VALID) /\
    (ack(t) == ACK_VALID)
ENDDEF

FUNCDEF synack ( sport :: Int; dport :: Int ) :: TCPPacket ::=
    TCPPacket(sport, dport, SEQ_VALID, ACK_VALID, CONS(ACK, CONS(SYN, NIL)), "")
ENDDEF

FUNCDEF syn ( sport :: Int; dport :: Int ) :: TCPPacket ::=
    TCPPacket(sport, dport, SEQ_VALID, ACK_VALID, CONS(SYN, NIL), "")
ENDDEF

FUNCDEF ack ( sport :: Int; dport :: Int ) :: TCPPacket ::=
    TCPPacket(sport, dport, SEQ_VALID, ACK_VALID, CONS(ACK, NIL), "")
ENDDEF

STAUTDEF sutPassiveOpenStaut [ InSutNet :: TCPPacket; OutSutNet :: TCPPacket; InSutUser :: TCPUserCallInput; OutSutUser :: TCPUserCallOutput ] ( )
   ::=
        STATE
            qclosed, qlisten, qsynrecv_1, qsynrecv_2, qestablished,qcompleted
        VAR
            st_src_port :: Int; st_dst_port :: Int
        INIT
            qclosed { st_src_port := 0; st_dst_port := 0 }
        TRANS
            qclosed ->  InSutUser ? c [[ isListenUserCall(c) ]] { st_src_port := lport(c) } ->  qlisten
            qlisten ->  InSutNet ? s [[ (dport(s) == st_src_port) /\ isSyn(s) ]] { st_dst_port := sport(s) } -> qsynrecv_1
            qsynrecv_1 -> OutSutNet ! synack(st_src_port, st_dst_port) -> qsynrecv_2
            qsynrecv_2 -> InSutNet ? a [[ isAck(a) ]] -> qestablished
            qestablished -> OutSutUser ? r [[ isSUCCESS(r) ]] -> qcompleted
ENDDEF
-- ----------------------------------------------------------------------------------------- --
-- model definition for the Queue system
--   declaring channel In  as input channel  (Queue system point of view)
--   declaring channel Out as output channel (Queue system point of view)
--   initializing queueStaut with channels In and Out and no parameters

MODELDEF  Echo
   ::=
        CHAN IN    InSutNet, InSutUser
        CHAN OUT   OutSutNet, OutSutUser

        BEHAVIOUR sutPassiveOpenStaut [ InSutNet, OutSutNet, InSutUser, OutSutUser ] ( )
ENDDEF


-- ----------------------------------------------------------------------------------------- --
-- definition of the tester connection to the sut
--   the tester is acting as client on a socket
--   channel In is declared as output (tester point of view), mapped to socket (localhost,7890),
--     a message of type QueueOp on channel In is encoded as string with standard function toString
--   channel Out is declared as input (tester point of view), mapped to socket (localhost,7890),
--     a received string on socket (localhost,7890), which must represent an integer,
--     is decoded with standard function fromString and forwarded to channel Out

CNECTDEF  Sut
   ::=
        CLIENTSOCK

        CHAN  OUT  InSutNet                     HOST "localhost"  PORT 3000
        ENCODE     InSutNet ? x                 ->  ! toString(x)

        CHAN  IN   OutSutNet                    HOST "localhost"  PORT 3000
        DECODE     OutSutNet ! fromString(s)    <-  ? s

        CHAN  OUT  InSutUser                    HOST "192.168.1.147"  PORT 3001
        ENCODE     InSutUser ? t                ->  ! toString(t)

        CHAN  IN   OutSutUser                   HOST "192.168.1.147"  PORT 3001
        DECODE     OutSutUser ! fromString(m)   <-  ? m
ENDDEF

-- ----------------------------------------------------------------------------------------- --
-- ----------------------------------------------------------------------------------------- --

